// -------------------------------------------------------------
// 
// File Name: C:\Users\frank\Matlab\PRUEBA_FLOAT_TO_FIXED\codegen\fcc\hdlsrc\fcc_fixpt.v
// Created: 2025-12-01 17:19:11
// 
// Generated by MATLAB 23.2, MATLAB Coder 23.2 and HDL Coder 23.2
// 
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Design base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// D1                            ce_out        1
// D2                            ce_out        1
// ui                            ce_out        1
// uv                            ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: fcc_fixpt
// Source Path: fcc_fixpt
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module fcc_fixpt
          (clk,
           reset,
           clk_enable,
           Vfcref,
           Vfc,
           Voutref,
           Vout,
           ce_out,
           D1,
           D2,
           ui,
           uv);


  input   clk;
  input   reset;
  input   clk_enable;
  input   [15:0] Vfcref;  // ufix16
  input   [15:0] Vfc;  // ufix16
  input   [15:0] Voutref;  // ufix16
  input   [15:0] Vout;  // ufix16
  output  ce_out;
  output  [6:0] D1;  // ufix7
  output  [6:0] D2;  // ufix7
  output  [20:0] ui;  // ufix21_En14
  output  signed [10:0] uv;  // sfix11_En14


  wire enb;
  wire [20:0] ex;  // ufix21_En14
  wire [20:0] ex_1;  // ufix21_En14
  reg [20:0] xUik [0:1];  // ufix21_En14 [2]
  wire [20:0] tmp;  // ufix21_En14
  wire tmp_1;
  wire [20:0] tmp_2;  // ufix21_En14
  wire tmp_3;
  wire [20:0] tmp_4;  // ufix21_En14
  reg signed [19:0] tmp_5 [0:1];  // sfix20_En14 [2]
  reg signed [19:0] xXik [0:1];  // sfix20_En14 [2]
  reg signed [19:0] xXik_1 [0:1];  // sfix20_En14 [2]
  reg [20:0] xUik_1 [0:1];  // ufix21_En14 [2]
  reg [20:0] tmp_6 [0:1];  // ufix21_En14 [2]
  reg [20:0] xUik_2 [0:1];  // ufix21_En14 [2]
  wire [20:0] ui_aux;  // ufix21_En14
  wire signed [20:0] ex_2;  // sfix21_En14
  wire signed [20:0] ex_3;  // sfix21_En14
  reg signed [10:0] xUik_3 [0:1];  // sfix11_En14 [2]
  wire signed [20:0] x;  // sfix21_En14
  wire tmp_7;
  wire signed [20:0] tmp_8;  // sfix21_En14
  wire tmp_9;
  wire signed [20:0] tmp_10;  // sfix21_En14
  wire signed [10:0] tmp_11;  // sfix11_En14
  reg signed [5:0] tmp_12 [0:1];  // sfix6_En14 [2]
  reg signed [5:0] xXik_2 [0:1];  // sfix6_En14 [2]
  reg signed [5:0] xXik_3 [0:1];  // sfix6_En14 [2]
  reg signed [10:0] xUik_4 [0:1];  // sfix11_En14 [2]
  reg signed [10:0] tmp_13 [0:1];  // sfix11_En14 [2]
  reg signed [10:0] xUik_5 [0:1];  // sfix11_En14 [2]
  wire signed [10:0] tmp_14;  // sfix11_En14
  wire signed [8:0] y1;  // sfix9
  wire signed [22:0] p45y1_add_cast;  // sfix23_En14
  wire signed [22:0] p45y1_add_cast_1;  // sfix23_En14
  wire signed [22:0] p45y1_add_temp;  // sfix23_En14
  wire [6:0] D1_aux;  // ufix7
  wire signed [8:0] y1_1;  // sfix9
  wire signed [22:0] p47y1_sub_cast;  // sfix23_En14
  wire signed [22:0] p47y1_sub_cast_1;  // sfix23_En14
  wire signed [22:0] p47y1_sub_temp;  // sfix23_En14
  wire [6:0] D2_aux;  // ufix7
  reg signed [31:0] xXik_reg_t_0_0;  // int32
  reg signed [31:0] p37xXik_t_0;  // int32
  reg signed [31:0] p35tmp_t_0;  // int32
  reg signed [21:0] p35tmp_cast;  // sfix22_En14
  reg signed [34:0] p35tmp_mul_temp;  // sfix35_En28
  reg signed [33:0] p35tmp_add_cast;  // sfix34_En28
  reg signed [34:0] p35tmp_add_cast_0;  // sfix35_En28
  reg signed [33:0] p35tmp_mul_temp_0;  // sfix34_En28
  reg signed [32:0] p35tmp_add_cast_1;  // sfix33_En28
  reg signed [34:0] p35tmp_add_cast_2;  // sfix35_En28
  reg signed [34:0] p35tmp_add_temp;  // sfix35_En28
  reg signed [31:0] xUik_reg_t_0_0;  // int32
  reg signed [31:0] p36xUik_t_0;  // int32
  reg signed [31:0] p33xUik_t_0;  // int32
  reg [17:0] p33xUik_sub_cast;  // ufix18_En14
  reg [15:0] p33xUik_sub_cast_0;  // ufix16_En14
  reg signed [18:0] p33xUik_sub_cast_1;  // sfix19_En14
  reg [17:0] p33xUik_sub_cast_2;  // ufix18_En14
  reg [15:0] p33xUik_sub_cast_3;  // ufix16_En14
  reg signed [18:0] p33xUik_sub_cast_4;  // sfix19_En14
  reg signed [18:0] p33xUik_sub_temp;  // sfix19_En14
  reg signed [20:0] p33xUik_sub_cast_5;  // sfix21_En14
  reg signed [20:0] p33xUik_sub_cast_6;  // sfix21_En14
  reg signed [20:0] p33xUik_sub_temp_0;  // sfix21_En14
  reg signed [37:0] p33xUik_mul_temp;  // sfix38_En28
  reg signed [36:0] p33xUik_cast;  // sfix37_En28
  reg signed [31:0] p22tmp_t_0;  // int32
  reg signed [31:0] p19xXik_t_0;  // int32
  reg signed [31:0] p17tmp_t_0;  // int32
  reg signed [16:0] p17tmp_mul_temp;  // sfix17_En28
  reg signed [20:0] p17tmp_add_cast;  // sfix21_En28
  reg signed [20:0] p17tmp_mul_temp_0;  // sfix21_En28
  reg signed [19:0] p17tmp_add_cast_0;  // sfix20_En28
  reg signed [20:0] p17tmp_add_cast_1;  // sfix21_En28
  reg signed [20:0] p17tmp_add_temp;  // sfix21_En28
  reg signed [31:0] p18xUik_t_0;  // int32
  reg signed [31:0] p15xUik_t_0;  // int32
  reg [17:0] p15xUik_sub_cast;  // ufix18_En14
  reg [15:0] p15xUik_sub_cast_0;  // ufix16_En14
  reg signed [18:0] p15xUik_sub_cast_1;  // sfix19_En14
  reg [17:0] p15xUik_sub_cast_2;  // ufix18_En14
  reg [15:0] p15xUik_sub_cast_3;  // ufix16_En14
  reg signed [18:0] p15xUik_sub_cast_4;  // sfix19_En14
  reg signed [18:0] p15xUik_sub_temp;  // sfix19_En14
  reg signed [19:0] p15xUik_sub_cast_5;  // sfix20_En14
  reg signed [19:0] p15xUik_sub_cast_6;  // sfix20_En14
  reg signed [19:0] p15xUik_sub_temp_0;  // sfix20_En14
  reg signed [38:0] p15xUik_mul_temp;  // sfix39_En28
  reg signed [37:0] p15xUik_cast;  // sfix38_En28
  reg signed [31:0] p39tmp_t_0;  // int32


  assign enb = clk_enable;

  // HDL code generation from MATLAB function: fcc_fixpt_trueregionp28
  assign ex = 21'b000000000000000000000;



  // HDL code generation from MATLAB function: fcc_fixpt_trueregionp23
  assign ex_1 = 21'b111111100000000000000;



  // HDL code generation from MATLAB function: fcc_fixpt_falseregionp28
  assign tmp = xUik[0];



  assign tmp_1 = 1'b0;



  // HDL code generation from MATLAB function: fcc_fixpt_falseregionp23
  assign tmp_2 = (tmp_1 == 1'b0 ? tmp :
              ex);



  assign tmp_3 = tmp_2 > 21'b111111100000000000000;



  assign tmp_4 = (tmp_3 == 1'b0 ? tmp_2 :
              ex_1);



  always @(posedge clk or posedge reset)
    begin : xXik_reg_process
      if (reset == 1'b1) begin
        xXik[0] <= 20'sb00000000000000000000;
        xXik[1] <= 20'sb00000000000000000000;
      end
      else begin
        if (enb) begin
          for(xXik_reg_t_0_0 = 32'sd0; xXik_reg_t_0_0 <= 32'sd1; xXik_reg_t_0_0 = xXik_reg_t_0_0 + 32'sd1) begin
            xXik[xXik_reg_t_0_0] <= tmp_5[xXik_reg_t_0_0];
          end
        end
      end
    end



  // PI cálculo
  always @* begin

    for(p37xXik_t_0 = 32'sd0; p37xXik_t_0 <= 32'sd1; p37xXik_t_0 = p37xXik_t_0 + 32'sd1) begin
      xXik_1[p37xXik_t_0] = xXik[p37xXik_t_0];
    end

    xXik_1[1] = xXik[0];
  end



  always @* begin

    for(p35tmp_t_0 = 32'sd0; p35tmp_t_0 <= 32'sd1; p35tmp_t_0 = p35tmp_t_0 + 32'sd1) begin
      tmp_5[p35tmp_t_0] = xXik_1[p35tmp_t_0];
    end

    p35tmp_cast = {1'b0, xUik_1[1]};
    p35tmp_mul_temp = 13'sb1010011010011 * p35tmp_cast;
    p35tmp_add_cast = p35tmp_mul_temp[33:0];
    p35tmp_add_cast_0 = {p35tmp_add_cast[33], p35tmp_add_cast};
    p35tmp_mul_temp_0 = 14'sb01110000010101 * xXik_1[1];
    p35tmp_add_cast_1 = p35tmp_mul_temp_0[32:0];
    p35tmp_add_cast_2 = {{2{p35tmp_add_cast_1[32]}}, p35tmp_add_cast_1};
    p35tmp_add_temp = p35tmp_add_cast_0 + p35tmp_add_cast_2;
    tmp_5[0] = p35tmp_add_temp[33:14];
  end



  always @(posedge clk or posedge reset)
    begin : xUik_reg_process
      if (reset == 1'b1) begin
        xUik_2[0] <= 21'b000000000000000000000;
        xUik_2[1] <= 21'b000000000000000000000;
      end
      else begin
        if (enb) begin
          for(xUik_reg_t_0_0 = 32'sd0; xUik_reg_t_0_0 <= 32'sd1; xUik_reg_t_0_0 = xUik_reg_t_0_0 + 32'sd1) begin
            xUik_2[xUik_reg_t_0_0] <= tmp_6[xUik_reg_t_0_0];
          end
        end
      end
    end



  always @* begin

    for(p36xUik_t_0 = 32'sd0; p36xUik_t_0 <= 32'sd1; p36xUik_t_0 = p36xUik_t_0 + 32'sd1) begin
      xUik_1[p36xUik_t_0] = xUik_2[p36xUik_t_0];
    end

    xUik_1[1] = xUik_2[0];
  end



  // HDL code generation from MATLAB function: fcc_fixpt
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  //                                                                          %
  //          Generated by MATLAB 23.2 and Fixed-Point Designer 23.2          %
  //                                                                          %
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // function out = pivf_fun(varargin)
  // Declarar todas las variables persistentes al inicio
  // Inicializar si es primera vez
  // Asignación de parámetros
  always @* begin

    for(p33xUik_t_0 = 32'sd0; p33xUik_t_0 <= 32'sd1; p33xUik_t_0 = p33xUik_t_0 + 32'sd1) begin
      xUik[p33xUik_t_0] = xUik_1[p33xUik_t_0];
    end

    p33xUik_sub_cast = {2'b0, Voutref};
    p33xUik_sub_cast_0 = p33xUik_sub_cast[15:0];
    p33xUik_sub_cast_1 = {3'b0, p33xUik_sub_cast_0};
    p33xUik_sub_cast_2 = {2'b0, Vout};
    p33xUik_sub_cast_3 = p33xUik_sub_cast_2[15:0];
    p33xUik_sub_cast_4 = {3'b0, p33xUik_sub_cast_3};
    p33xUik_sub_temp = p33xUik_sub_cast_1 - p33xUik_sub_cast_4;
    p33xUik_sub_cast_5 = {{2{p33xUik_sub_temp[18]}}, p33xUik_sub_temp};
    p33xUik_sub_cast_6 = {tmp_5[0][19], tmp_5[0]};
    p33xUik_sub_temp_0 = p33xUik_sub_cast_5 - p33xUik_sub_cast_6;
    p33xUik_mul_temp = 17'sb01100110110111100 * p33xUik_sub_temp_0;
    p33xUik_cast = p33xUik_mul_temp[36:0];
    xUik[0] = p33xUik_cast[34:14];
  end



  always @* begin

    for(p22tmp_t_0 = 32'sd0; p22tmp_t_0 <= 32'sd1; p22tmp_t_0 = p22tmp_t_0 + 32'sd1) begin
      tmp_6[p22tmp_t_0] = xUik[p22tmp_t_0];
    end

    tmp_6[0] = tmp_4;
  end



  assign ui_aux = tmp_6[0];



  // HDL code generation from MATLAB function: fcc_fixpt_trueregionp9
  assign ex_2 = 21'sb101101000000000000000;



  // HDL code generation from MATLAB function: fcc_fixpt_trueregionp4
  assign ex_3 = 21'sb010011000000000000000;



  // HDL code generation from MATLAB function: fcc_fixpt_falseregionp9
  assign x = {{10{xUik_3[0][10]}}, xUik_3[0]};



  assign tmp_7 = x < 21'sb101101000000000000000;



  // HDL code generation from MATLAB function: fcc_fixpt_falseregionp4
  assign tmp_8 = (tmp_7 == 1'b0 ? x :
              ex_2);



  assign tmp_9 = tmp_8 > 21'sb010011000000000000000;



  assign tmp_10 = (tmp_9 == 1'b0 ? tmp_8 :
              ex_3);



  assign tmp_11 = tmp_10[10:0];



  always @(posedge clk or posedge reset)
    begin : xXik_reg_1_process
      if (reset == 1'b1) begin
        xXik_2[0] <= 6'sb000000;
        xXik_2[1] <= 6'sb000000;
      end
      else begin
        if (enb) begin
          for(xXik_reg_t_0_0 = 32'sd0; xXik_reg_t_0_0 <= 32'sd1; xXik_reg_t_0_0 = xXik_reg_t_0_0 + 32'sd1) begin
            xXik_2[xXik_reg_t_0_0] <= tmp_12[xXik_reg_t_0_0];
          end
        end
      end
    end



  // PI cálculo
  always @* begin

    for(p19xXik_t_0 = 32'sd0; p19xXik_t_0 <= 32'sd1; p19xXik_t_0 = p19xXik_t_0 + 32'sd1) begin
      xXik_3[p19xXik_t_0] = xXik_2[p19xXik_t_0];
    end

    xXik_3[1] = xXik_2[0];
  end



  always @* begin

    for(p17tmp_t_0 = 32'sd0; p17tmp_t_0 <= 32'sd1; p17tmp_t_0 = p17tmp_t_0 + 32'sd1) begin
      tmp_12[p17tmp_t_0] = xXik_3[p17tmp_t_0];
    end

    p17tmp_mul_temp = 6'sb101110 * xUik_4[1];
    p17tmp_add_cast = {{4{p17tmp_mul_temp[16]}}, p17tmp_mul_temp};
    p17tmp_mul_temp_0 = 15'sb011111100011110 * xXik_3[1];
    p17tmp_add_cast_0 = p17tmp_mul_temp_0[19:0];
    p17tmp_add_cast_1 = {p17tmp_add_cast_0[19], p17tmp_add_cast_0};
    p17tmp_add_temp = p17tmp_add_cast + p17tmp_add_cast_1;
    tmp_12[0] = p17tmp_add_temp[19:14];
  end



  always @(posedge clk or posedge reset)
    begin : xUik_reg_1_process
      if (reset == 1'b1) begin
        xUik_5[0] <= 11'sb00000000000;
        xUik_5[1] <= 11'sb00000000000;
      end
      else begin
        if (enb) begin
          for(xUik_reg_t_0_0 = 32'sd0; xUik_reg_t_0_0 <= 32'sd1; xUik_reg_t_0_0 = xUik_reg_t_0_0 + 32'sd1) begin
            xUik_5[xUik_reg_t_0_0] <= tmp_13[xUik_reg_t_0_0];
          end
        end
      end
    end



  always @* begin

    for(p18xUik_t_0 = 32'sd0; p18xUik_t_0 <= 32'sd1; p18xUik_t_0 = p18xUik_t_0 + 32'sd1) begin
      xUik_4[p18xUik_t_0] = xUik_5[p18xUik_t_0];
    end

    xUik_4[1] = xUik_5[0];
  end



  // function out = pivf_fun(varargin)
  // Declarar todas las variables persistentes al inicio
  // Inicializar si es primera vez
  // Asignación de parámetros
  always @* begin

    for(p15xUik_t_0 = 32'sd0; p15xUik_t_0 <= 32'sd1; p15xUik_t_0 = p15xUik_t_0 + 32'sd1) begin
      xUik_3[p15xUik_t_0] = xUik_4[p15xUik_t_0];
    end

    p15xUik_sub_cast = {2'b0, Vfcref};
    p15xUik_sub_cast_0 = p15xUik_sub_cast[15:0];
    p15xUik_sub_cast_1 = {3'b0, p15xUik_sub_cast_0};
    p15xUik_sub_cast_2 = {2'b0, Vfc};
    p15xUik_sub_cast_3 = p15xUik_sub_cast_2[15:0];
    p15xUik_sub_cast_4 = {3'b0, p15xUik_sub_cast_3};
    p15xUik_sub_temp = p15xUik_sub_cast_1 - p15xUik_sub_cast_4;
    p15xUik_sub_cast_5 = {p15xUik_sub_temp[18], p15xUik_sub_temp};
    p15xUik_sub_cast_6 = {{14{tmp_12[0][5]}}, tmp_12[0]};
    p15xUik_sub_temp_0 = p15xUik_sub_cast_5 - p15xUik_sub_cast_6;
    p15xUik_mul_temp = 19'sb0110010010101100001 * p15xUik_sub_temp_0;
    p15xUik_cast = p15xUik_mul_temp[37:0];
    xUik_3[0] = p15xUik_cast[24:14];
  end



  always @* begin

    for(p39tmp_t_0 = 32'sd0; p39tmp_t_0 <= 32'sd1; p39tmp_t_0 = p39tmp_t_0 + 32'sd1) begin
      tmp_13[p39tmp_t_0] = xUik_3[p39tmp_t_0];
    end

    tmp_13[0] = tmp_11;
  end



  assign tmp_14 = tmp_13[0];



  assign p45y1_add_cast = {2'b0, ui_aux};
  assign p45y1_add_cast_1 = {{12{tmp_14[10]}}, tmp_14};
  assign p45y1_add_temp = p45y1_add_cast + p45y1_add_cast_1;
  assign y1 = p45y1_add_temp[22:14] + $signed({1'b0, p45y1_add_temp[22] & (|p45y1_add_temp[13:0])});



  assign D1_aux = y1[6:0];



  assign p47y1_sub_cast = {2'b0, ui_aux};
  assign p47y1_sub_cast_1 = {{12{tmp_14[10]}}, tmp_14};
  assign p47y1_sub_temp = p47y1_sub_cast - p47y1_sub_cast_1;
  assign y1_1 = p47y1_sub_temp[22:14] + $signed({1'b0, p47y1_sub_temp[22] & (|p47y1_sub_temp[13:0])});



  assign D2_aux = y1_1[6:0];



  assign ce_out = clk_enable;

  assign D1 = D1_aux;

  assign D2 = D2_aux;

  assign ui = ui_aux;

  assign uv = tmp_14;

endmodule  // fcc_fixpt

